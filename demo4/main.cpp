/* 引用caller1.cpp中的caller1函数 */
void caller1();
/* 引用caller2.cpp中的caller2函数 */
void caller2();

int main() {
	caller1();
	caller2();
	return 0;
}

/*
 * 上述函数的运行结果为:
 * func1: 1
 * func1: 0.1
 * func1: 2
 * func2: 0.2
 * 我们看到,第三行的输出结果,按照常理说应该调用的caller2.cpp中的函数模板的实例.
 * 应该输出以func2开头的函数调用结果.
 * 通过caller1.cpp和caller2.cpp的代码可知,
 * caller1.cpp中会编译生成func<int>和func<double>两个函数模板的实例.
 * caller2.cpp中会编译生成func<int>和func<float>两个函数模板的实例.
 * 但是,caller1.cpp和caller2.cpp的目标文件与main.cpp文件的目标文件进行连接时,
 * 很显然,caller1.cpp目标文件中的func<int>模板函数实例覆盖了caller2.cpp目标文件的中func<int>()这个模板函数实例.
 * 因为,caller1.cpp目标文件和caller2.cpp目标文件中func<int>实例的函数名、模板实参列表以及参数列表都是相同的,
 * 所以,编译器便认为这个两个实例相同,保留了第一个实例,而忽略了第二个实例.
 * 所以,CPP的编译器不考虑函数的具体内容,仅仅通过函数名、模板实参列表以及参数列表等接口信息来判断两个函数是否等价.
 * 而编译器在选择具体哪一个函数实例时随机的.
 * 通过上述的接口信息的方法去判断函数实例是否等价,可以有效解决模板实例重复的问题
 * 但是,这样也会有弊端.
 * 想想,如果在不同的库函数中,有两个模板函数的函数名,模板实参列表以及参数列表相同.
 * 但是,函数的实现内容不同.
 * 如果,在程序中引用了这两个库函数,那么在编译时,根据编译器判断函数等价的原则,
 * 那么,两个库中的函数就会有一个被覆盖掉.
 * 这样程序执行就会出现差错.
 * 通过避免使用相同的函数名可以尽量降低这一可能性.
 * 最有效的解决办法是使用CPP的命名空间机制.
 * 通过命名空间调用函数,则自然可以避免上述问题.
 */