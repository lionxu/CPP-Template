#pragma once
/*
 * 在这里把函数模板的声明和实现放在一个头文件内
 * 在CPP的编译器中,函数模板的实例,是在调用该函数模板的时候自动生成相应类型的实例
 * 如果,我们按照CPP常规的编码方式,
 * 即,在.h的头文件中存放函数的声明,在.cpp文件中存放函数的实现.
 * 这样,在编译程序时,编译器就会爆出模板函数的某个实例未定义的错误.
 * 如果,我们需要使用所定义的函数模板时,就会在某个.cpp源文件中通过include预处理指令包含该.h头文件
 * 但是.h头文件中只包含了该函数模板的声明,并没有该函数模板的实现.
 * 所以,在该源文件中即使有此函数模板的调用,但是,编译器无法找到该函数模板的实现.
 * 所以,编译器是无法生成该函数模板的调用实例的,所以只能保留一个调用链接,希望在函数链接的过程中可以找到函数的实现.
 * 因为,函数模板的实现放在.cpp的实现文件中,但是编译器在编译该源文件的时候,但是没有发现该模板函数的调用
 * 所以,编译器不会生成相应的函数调用实例.
 * 那么,就导致了在链接阶段,就会出现无法找到某个函数模板实例的错误.
 * 
 * 所以,我们把模板函数的声明和实现放在同一个头文件中,
 * 这样,如果某一个源文件需要用到该模板函数,在包含该头文件的时候,也会把该模板函数的实现包含进文件中.
 * 这样,当编译器需要生成模板函数调用的实例时,就可以直接生成该函数调用实例.
 * 而无需依赖其他的目标文件中生成的实例,同时,也可以解决上述问题.
 * 但是,这样做会带来一个问题,即,模板实例重复的问题.
 * 当有多个源文件包含了某个模板函数定义的头文件,而且每个源文件都会有一个该模板函数的相同调用.
 * 那么,在每个源文件中都会生成一个该函数模板的调用实例.
 * 而且,这些模板实例都是完全相同等价的.
 * 如果在最后的链接阶段不做特殊处理,那么在最终的目标代码中,就会有多个相同的函数调用实例.
 * 这样就会造成目标文件的尺寸大增.
 * 尤其是在大量使用模板函数的时候,情况尤其严重.
 * 对于上述问题,CPP标准给出的解决方案是,在链接时识别并合并等价的模板实例.
 */
template<typename T> T const& func(T const &v);
template <typename T> T const& func(T const &v) { return v; }